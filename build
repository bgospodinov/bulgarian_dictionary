#!/bin/bash
set -e
set -o pipefail

PROCESS_SLOVNIK=true

while [[ $# -gt 0 ]]
do
	key="$1"
	case $key in
		--no-slovnik)
			PROCESS_SLOVNIK=
			shift;
		;;
		*)
			>&2 echo "Unknown option" $key
			shift;
			exit 1;
		;;
	esac
done

if [ $PROCESS_SLOVNIK ] ; then
	SALT="%D*HUKFTV:"
	function pass {
		echo Enter Slovnik password \(or rerun with option --no-slovnik\):
		read -s SLOVNIK_PASS
		PASS_HASH=$(echo -n ${SLOVNIK_PASS}$SALT | sha512sum | sha512sum | awk '{print $1}')
	}

	pass

	while [[ "$PASS_HASH" != "6d70366494981ca988a60c2e9f72fc157496896a602981c80ba828e1ac5030462fc4704bff5cb475accf8dc0a3efac703922c47c33e3ecf5c1163ad7ae89378f" ]]
	do
		echo -e "Slovnik pass is wrong. Try again."
		pass
	done
fi

echo Sourcing configuration from header files...
CONFIG=$(sed -r '{
        /^#define/!d
        /#define[ \t]*[^ \t]*$/d
        s/[^ \t]*[ \t]*([^ \t]*)[ \t]*(.*)/\1="\2"/
		s/""/"/g
        /(""|\([^\)]*\))/d
    }' <(cat inc/*.h))

echo "$CONFIG";
eval "$CONFIG"

SCRATCH_PATH=$(mktemp -d -t bdict.XXXXXXXXXX)
RESOURCES_PATH=resources
PIPELINE_PATH=pipeline
SLOVNIK_PATH=$SCRATCH_PATH/slovnik
DB_RECHKO_PATH=$SCRATCH_PATH/rechko.db # this allows concurrent insertion
DB_MAIN_PATH=$SCRATCH_PATH/main.db # in the end, everything is merged here
DB_FINAL_PATH=dictionary.db # where the artifact gets deployed (relative to PWD)

function finish {
	echo Temporary files removed.
	rm -rf "$SCRATCH_PATH"
}

trap finish EXIT

(
	if [ $PROCESS_SLOVNIK ] ; then
		##### SLOVNIK SECTION START #####
		echo Building db setup code...
		make

		echo Decrypting and unpacking Slovnik...
		openssl enc -aes-256-cbc -d -in $RESOURCES_PATH/slovnik.tar.gz.enc -pbkdf2 -pass "pass:$SLOVNIK_PASS" | tar -xz -C $SCRATCH_PATH

		# assembling slovnik into one csv file
		rm -f $SLOVNIK_PATH/all.txt;
		for f in $SLOVNIK_PATH/*.txt; do
			(cat "${f}"; printf "\n") >> $SCRATCH_PATH/$SLOVNIK_FILE_NAME
			rm -f $f
		done

		rm -rf $SLOVNIK_PATH

		echo Importing slovnik wordforms...
		sqlite3 $DB_MAIN_PATH ".read pipeline/10_create_slovnik_wordform.sql"
		./bin/import_slovnik $SCRATCH_PATH ${DB_MAIN_PATH##*/}
		rm -f $SCRATCH_PATH/$SLOVNIK_FILE_NAME
		##### SLOVNIK SECTION END #####
	fi

	###### RBE SECTION START #####
	echo Unpacking RBE...
	zcat $RESOURCES_PATH/db-rbe.sql.gz > $SCRATCH_PATH/db-rbe.sql

	echo Cleaning RBE...
	parallel -a $SCRATCH_PATH/db-rbe.sql --block 30M --pipe-part \
		"sed -n -E -f $PIPELINE_PATH/20_*.sed |\
			sed -E -f $PIPELINE_PATH/21_*.sed" \
				>$SCRATCH_PATH/db-rbe.csv
	rm -f $SCRATCH_PATH/db-rbe.sql

	echo Importing RBE lemmata into database...;
	sqlite3 $DB_MAIN_PATH ".read pipeline/30_create_rbe_lemma.sql";
	sqlite3 $DB_MAIN_PATH ".mode csv" ".separator ^" ".import $SCRATCH_PATH/db-rbe.csv rbe_lemma";
	sqlite3 $DB_MAIN_PATH "CREATE VIRTUAL TABLE rbe_lemma_ft USING fts5(source_definition, content=rbe_lemma);" "INSERT INTO rbe_lemma_ft SELECT source_definition FROM rbe_lemma;";
	sqlite3 $DB_MAIN_PATH ".read pipeline/31_add_pos_to_rbe_lemma.sql"
	sqlite3 $DB_MAIN_PATH ".read pipeline/32_fix_rbe_lemma_errors.sql"
	sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_rbe_lemma ON rbe_lemma(lemma);";
	sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_rbe_lemma_stress_pos ON rbe_lemma(lemma_with_stress, pos);";
	rm -f $SCRATCH_PATH/db-rbe.csv;
	##### RBE SECTION END #####
) &

(
	##### RECHKO SECTION START #####
	echo Unpacking Rechko...
	zcat $RESOURCES_PATH/db-rechko.sql.gz > $SCRATCH_PATH/db-rechko.sql

	echo Converting Rechko MySQL dump to SQLite
	./scripts/mysql2sqlite.awk $SCRATCH_PATH/db-rechko.sql > $SCRATCH_PATH/db-rechko.sqlite
	rm -f $SCRATCH_PATH/db-rechko.sql

	echo Importing Rechko...
	sqlite3 $DB_RECHKO_PATH ".read $SCRATCH_PATH/db-rechko.sqlite"
	rm -f $SCRATCH_PATH/db-rechko.sqlite

	echo Cleaning Rechko...
	# useful tables from Rechko: derivative_form, word, word_type
	sqlite3 $DB_RECHKO_PATH "ALTER TABLE word RENAME TO rechko_lemma;"
	sqlite3 $DB_RECHKO_PATH "CREATE INDEX IF NOT EXISTS idx_rechko_lemma ON rechko_lemma(name);"
	sqlite3 $DB_RECHKO_PATH "DROP TABLE abstract_word; DROP TABLE incorrect_form; DROP TABLE incorrect_form_revision; DROP TABLE revision; DROP TABLE sf_guard_group; DROP TABLE sf_guard_group_permission; DROP TABLE sf_guard_permission; DROP TABLE sf_guard_remember_key; DROP TABLE sf_guard_user; DROP TABLE sf_guard_user_group; DROP TABLE sf_guard_user_permission; DROP TABLE sf_guard_user_profile; DROP TABLE word_revision; DROP TABLE word_translation;"
	##### RECHKO SECTION END #####
) &

wait

echo Joining RBE lemmata with Rechko lemmata
sqlite3 $DB_MAIN_PATH "ATTACH '$DB_RECHKO_PATH' as rechko;" ".load lib/libextfun" ".read pipeline/33_join_rechko_lemma.sql" "DETACH rechko;"

echo Creating lemma indices
sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_lemma_pos ON lemma(lemma, pos);"
sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_lemma_stressed_pos ON lemma(lemma_stressed, pos);"

if [ $PROCESS_SLOVNIK ] ; then
	echo Joining Slovnik lemmata with lemmata
	sqlite3 $DB_MAIN_PATH ".load lib/libextfun" ".read pipeline/34_join_slovnik_lemma.sql"
fi

echo Creating lemma fulltext index;
sqlite3 $DB_MAIN_PATH "CREATE VIRTUAL TABLE lemma_ft USING fts5(definition, content=lemma);" "INSERT INTO lemma_ft SELECT definition FROM lemma;";

echo Import Rechko wordforms
sqlite3 $DB_MAIN_PATH "ATTACH '$DB_RECHKO_PATH' as rechko;" ".load lib/libextfun" ".read pipeline/40_import_rechko_wordform.sql" "DETACH rechko;"
sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_wordform_tag ON wordform(wordform, tag);"
sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_rechko_wordform_tag ON rechko_wordform(wordform, tag);"
rm -f $DB_RECHKO_PATH

if [ $PROCESS_SLOVNIK ] ; then
	echo Joining Slovnik wordforms with Rechko wordforms
	sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_slovnik_wordform_tag ON slovnik_wordform(wordform, tag);"
	sqlite3 $DB_MAIN_PATH ".read pipeline/41_join_slovnik_wordforms.sql"
	sqlite3 $DB_MAIN_PATH "DROP TABLE IF EXISTS slovnik_wordform;"
fi

sqlite3 $DB_MAIN_PATH "DROP TABLE IF EXISTS rechko_wordform;"

echo Cleaning lemma and wordforms table
sqlite3 $DB_MAIN_PATH ".read pipeline/45_clean_lemma_wordform_table.sql"

echo Run tests on lemmata tables
sqlite3 -list $DB_MAIN_PATH ".read pipeline/50_test_lemma.sql" |
	diff tests/lemma.test -

echo Run tests on wordform table
sqlite3 -list $DB_MAIN_PATH ".read pipeline/51_test_wordform.sql" |
	diff tests/wordform.test -

# drop rechko_lemma and rbe_lemma tables
echo Deleting old lemma tables
sqlite3 $DB_MAIN_PATH "DROP TABLE rbe_lemma;" "DROP TABLE rechko_lemma;" "DROP TABLE rbe_lemma_ft;" "DROP TABLE rechko_word_type;"

echo Create stress table...
sqlite3 $DB_MAIN_PATH ".read pipeline/60_create_stress.sql"

echo Populating lemma table with stresses
sqlite3 $DB_MAIN_PATH ".load lib/libextfun" ".read pipeline/61_add_stress_to_lemma.sql"

echo Run tests on stresses
sqlite3 -list $DB_MAIN_PATH ".read pipeline/65_test_stress.sql" |
	diff tests/stress.test -

echo Vacuum...
sqlite3 $DB_MAIN_PATH "VACUUM"

echo Persisting temp database...
cp $DB_MAIN_PATH $DB_FINAL_PATH

echo Build finished. Success.
