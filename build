#!/bin/bash
set -e
set -o pipefail

SALT="%D*HUKFTV:"
function pass {
	echo Enter Slovnik password:
	read -s SLOVNIK_PASS
	PASS_HASH=$(echo -n ${SLOVNIK_PASS}$SALT | sha512sum | sha512sum | awk '{print $1}')
}

pass

while [[ "$PASS_HASH" != "6d70366494981ca988a60c2e9f72fc157496896a602981c80ba828e1ac5030462fc4704bff5cb475accf8dc0a3efac703922c47c33e3ecf5c1163ad7ae89378f" ]]
do
	echo -e "Slovnik pass is wrong. Try again."
	pass
done

echo Sourcing configuration from header files...
CONFIG=$(sed -r '{
        /^#define/!d
        /#define[ \t]*[^ \t]*$/d
        s/[^ \t]*[ \t]*([^ \t]*)[ \t]*(.*)/\1="\2"/
		s/""/"/g
        /(""|\([^\)]*\))/d
    }' <(cat inc/*.h))

echo "$CONFIG";
eval "$CONFIG"

SCRATCH_PATH=$(mktemp -d -t bdict.XXXXXXXXXX)
RESOURCES_PATH=resources
PIPELINE_PATH=pipeline
SLOVNIK_PATH=$SCRATCH_PATH/slovnik
DB_RECHKO_PATH=$SCRATCH_PATH/rechko.db # this allows concurrent insertion
DB_MAIN_PATH=$SCRATCH_PATH/main.db # in the end, everything is merged here
DB_FINAL_PATH=dictionary.db # where the artifact gets deployed (relative to PWD)

function finish {
	echo Temporary files removed.
	rm -rf "$SCRATCH_PATH"
}

trap finish EXIT

(
	##### SLOVNIK SECTION START #####
	echo Building db setup code...
	make

	echo Decrypting and unpacking Slovnik...
	openssl enc -aes-256-cbc -d -in $RESOURCES_PATH/slovnik.tar.gz.enc -pbkdf2 -pass "pass:$SLOVNIK_PASS" | tar -xz -C $SCRATCH_PATH

	# assembling slovnik into one csv file
	rm -f $SLOVNIK_PATH/all.txt;
	for f in $SLOVNIK_PATH/*.txt; do
		(cat "${f}"; printf "\n") >> $SCRATCH_PATH/$SLOVNIK_FILE_NAME
		rm -f $f
	done

	rm -rf $SLOVNIK_PATH

	echo Importing slovnik wordforms...
	sqlite3 $DB_MAIN_PATH ".read pipeline/10_create_slovnik_wordform.sql"
	./bin/import_slovnik $SCRATCH_PATH ${DB_MAIN_PATH##*/}
	rm -f $SCRATCH_PATH/$SLOVNIK_FILE_NAME
	##### SLOVNIK SECTION END #####

	###### RBE SECTION START #####
	echo Unpacking RBE...
	zcat $RESOURCES_PATH/db-rbe.sql.gz > $SCRATCH_PATH/db-rbe.sql

	echo Cleaning RBE...
	parallel -a $SCRATCH_PATH/db-rbe.sql --block 30M --pipe-part \
		"sed -n -E -f $PIPELINE_PATH/20_*.sed |\
			sed -E -f $PIPELINE_PATH/21_*.sed" \
				>$SCRATCH_PATH/db-rbe.csv
	rm -f $SCRATCH_PATH/db-rbe.sql

	echo Importing RBE lemmata into database...;
	sqlite3 $DB_MAIN_PATH ".read pipeline/30_create_rbe_lemma.sql";
	sqlite3 $DB_MAIN_PATH ".mode csv" ".separator ^" ".import $SCRATCH_PATH/db-rbe.csv rbe_lemma";
	sqlite3 $DB_MAIN_PATH "CREATE VIRTUAL TABLE rbe_lemma_ft USING fts5(source_definition, content=rbe_lemma);" "INSERT INTO rbe_lemma_ft SELECT source_definition FROM rbe_lemma;";
	sqlite3 $DB_MAIN_PATH ".read pipeline/31_add_pos_to_rbe_lemma.sql"
	sqlite3 $DB_MAIN_PATH ".read pipeline/32_fix_rbe_lemma_errors.sql"
	sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_rbe_lemma ON rbe_lemma(lemma);";
	sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_rbe_lemma_stress_pos ON rbe_lemma(lemma_with_stress, pos);";
	rm -f $SCRATCH_PATH/db-rbe.csv;
	##### RBE SECTION END #####
) &

(
	##### RECHKO SECTION START #####
	echo Unpacking Rechko...
	zcat $RESOURCES_PATH/db-rechko.sql.gz > $SCRATCH_PATH/db-rechko.sql

	echo Converting Rechko MySQL dump to SQLite
	./scripts/mysql2sqlite.awk $SCRATCH_PATH/db-rechko.sql > $SCRATCH_PATH/db-rechko.sqlite
	rm -f $SCRATCH_PATH/db-rechko.sql

	echo Importing Rechko...
	sqlite3 $DB_RECHKO_PATH ".read $SCRATCH_PATH/db-rechko.sqlite"
	rm -f $SCRATCH_PATH/db-rechko.sqlite

	echo Cleaning Rechko...
	# useful tables from Rechko: derivative_form, word, word_type
	sqlite3 $DB_RECHKO_PATH "ALTER TABLE word RENAME TO rechko_lemma;"
	sqlite3 $DB_RECHKO_PATH "CREATE INDEX IF NOT EXISTS idx_rechko_lemma ON rechko_lemma(name);"
	sqlite3 $DB_RECHKO_PATH "DROP TABLE abstract_word; DROP TABLE incorrect_form; DROP TABLE incorrect_form_revision; DROP TABLE revision; DROP TABLE sf_guard_group; DROP TABLE sf_guard_group_permission; DROP TABLE sf_guard_permission; DROP TABLE sf_guard_remember_key; DROP TABLE sf_guard_user; DROP TABLE sf_guard_user_group; DROP TABLE sf_guard_user_permission; DROP TABLE sf_guard_user_profile; DROP TABLE word_revision; DROP TABLE word_translation;"
	##### RECHKO SECTION END #####
) &

wait

echo Joining RBE lemmata with Rechko lemmata
sqlite3 $DB_MAIN_PATH "ATTACH '$DB_RECHKO_PATH' as rechko;" ".read pipeline/33_join_rechko_lemma.sql" "DETACH rechko;"

echo Creating lemma fulltext and other indices;
# drop rechko_lemma and rbe_lemma tables
sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_lemma ON lemma(name);"
sqlite3 $DB_MAIN_PATH "CREATE INDEX IF NOT EXISTS idx_lemma_stress_pos ON lemma(name_stressed, pos);"
sqlite3 $DB_MAIN_PATH "CREATE VIRTUAL TABLE lemma_ft USING fts5(source_definition, content=lemma);" "INSERT INTO lemma_ft SELECT source_definition FROM lemma;";

echo Run tests on lemmata tables
sqlite3 -list $DB_MAIN_PATH ".read pipeline/34_test_lemma.sql" |
	diff tests/lemma.test -

echo Import Rechko wordforms
sqlite3 $DB_MAIN_PATH "ATTACH '$DB_RECHKO_PATH' as rechko;" ".read pipeline/40_import_rechko_wordforms.sql" "DETACH rechko;"
rm -f $DB_RECHKO_PATH

echo Joining Slovnik wordforms with Rechko wordforms
#sqlite3 $DB_MAIN_PATH ".read pipeline/41_join_slovnik_wordforms.sql"

echo Run tests on wordform table
sqlite3 -list $DB_MAIN_PATH ".read pipeline/44_test_wordform.sql" |
	diff tests/wordform.test -

echo Cleaning lemma and wordforms table
sqlite3 $DB_MAIN_PATH ".read pipeline/45_clean_lemma_table.sql"

echo Deleting old lemma tables
sqlite3 $DB_MAIN_PATH "DROP TABLE rbe_lemma;" "DROP TABLE rechko_lemma;" "DROP TABLE rbe_lemma_ft;" "DROP TABLE rechko_word_type;"

echo Vacuum...
sqlite3 $DB_MAIN_PATH "VACUUM"

echo Create stress table...
sqlite3 $DB_MAIN_PATH ".read pipeline/50_create_stress.sql"

echo Persisting temp database...
cp $DB_MAIN_PATH $DB_FINAL_PATH

#echo Importing wordform stresses in stress table...
#python "pipeline/wordform_stress_importer.py"

echo Build finished. Success.
